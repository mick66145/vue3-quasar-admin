# SA 系統分析文件撰寫風格指南

> **版本：** v1.0
> **更新日期：** 2025-11-12
> **文件類型：** 系統分析與流程設計文件撰寫規範

---

## 📋 目錄

- [1. 概述](#1-概述)
- [2. 使用情境撰寫規範](#2-使用情境撰寫規範)
- [3. 流程圖繪製指南](#3-流程圖繪製指南)
- [4. 時序圖繪製指南](#4-時序圖繪製指南)
- [5. 事件流程描述](#5-事件流程描述)
- [6. 連線生命週期文件](#6-連線生命週期文件)
- [7. 完整情境範例](#7-完整情境範例)
- [8. 檢查清單](#8-檢查清單)

---

## 1. 概述

本文件規範了系統分析（System Analysis）相關文件的撰寫標準，專注於流程設計、使用情境描述和事件序列的視覺化呈現。

### 1.1 SA 文件撰寫目標

- ✅ **清晰的流程呈現**：使用視覺化元素展示系統行為和事件序列
- ✅ **實用的情境範例**：提供真實的使用場景，幫助開發者理解功能應用
- ✅ **完整的事件追蹤**：詳細記錄客戶端與伺服器之間的互動流程
- ✅ **多層次的視角**：從使用者操作、系統事件、技術實作等不同角度描述
- ✅ **易於維護更新**：使用標準化的格式，便於後續修改和擴充

### 1.2 SA 文件的核心組成

SA 文件應包含以下核心元素：

1. **使用情境範例**：描述實際應用場景
2. **流程圖**：展示系統流程和決策分支
3. **時序圖**：展示客戶端與伺服器的互動序列
4. **事件流程**：詳細列出事件觸發的順序和條件
5. **連線生命週期**：描述連線從建立到結束的完整過程

---

## 2. 使用情境撰寫規範

### 2.1 情境結構

每個使用情境應包含以下標準結構：

```markdown
### [編號] 情境[編號]：[情境名稱]

**流程說明：** [用一句話概述此情境的核心流程]

**事件流程：**

​```
[使用流程圖或事件列表描述詳細流程]
​```

**使用場景：**

1. [具體的使用場景 1]
2. [具體的使用場景 2]
3. [具體的使用場景 3]

**實作重點：**（可選）

- [重要的實作細節或注意事項]
- [技術要點]
```

### 2.2 情境命名規範

情境名稱應該：
- 清晰描述主要功能或操作
- 使用動詞開頭（例：建立、進入、發送、離開）
- 簡潔明確（5-10 個中文字）

**良好範例：**
- ✅ 情境一：建立 AI 助理聊天室
- ✅ 情境二：進入聊天室
- ✅ 情境三：AI 助理對話
- ✅ 情境四：使用者離開聊天室
- ✅ 情境五：斷線重連處理

**不良範例：**
- ❌ 情境一：聊天室
- ❌ 情境二：關於如何進入聊天室的流程
- ❌ 情境三：AI

### 2.3 流程說明撰寫原則

**使用主動語態：**
```markdown
✅ 使用者連線後，發送 joinRoom 事件加入指定的聊天室
❌ joinRoom 事件被使用者發送以加入聊天室
```

**明確指出角色：**
```markdown
✅ 使用者開啟應用程式後，連線到 WebSocket 並進入已存在的聊天室
❌ 開啟應用程式後，進入聊天室
```

**說明目的和結果：**
```markdown
✅ 使用者發送訊息後，AI 助理開始生成回覆，並在完成後推送訊息
❌ 使用者發送訊息，然後發生一些事情
```

### 2.4 使用場景列舉

每個情境應列出 2-5 個具體的使用場景，說明何時會觸發此流程：

```markdown
**使用場景：**

1. **初次連線**：使用者首次開啟應用程式
2. **切換房間**：使用者從一個聊天室切換到另一個聊天室
3. **重新整理頁面**：使用者刷新瀏覽器頁面
4. **斷線重連**：網路中斷後自動重新連線
```

### 2.5 實作重點（可選）

如果有重要的技術細節或注意事項，可以加入實作重點：

```markdown
**實作重點：**

- 先載入歷史訊息，讓使用者看到之前的對話記錄
- 再加入 WebSocket 房間，開始接收即時訊息
- 避免重複顯示訊息（區分歷史訊息和即時訊息）
- 處理連線超時的情況
```

---

## 3. 流程圖繪製指南

### 3.1 基本流程圖結構

使用 ASCII 字元繪製流程圖，標準符號：

| 符號    | 用途               | 範例                |
| ------- | ------------------ | ------------------- |
| `│`     | 垂直連接線         | 連接上下步驟        |
| `├─>`   | 分支（中間節點）   | 多個平行步驟        |
| `└─>`   | 分支（最後節點）   | 最後一個平行步驟    |
| `(處理中)` | 狀態或說明       | 標示當前狀態        |
| `[角色]` | 系統角色          | 標示執行者          |

### 3.2 基礎流程圖範例

**簡單的線性流程：**

```
使用者操作
  │
  ├─> 步驟 1: 建立連線
  │
  ├─> 步驟 2: 發送請求
  │
  ├─> 步驟 3: 接收回應
  │
  └─> 步驟 4: 顯示結果
```

### 3.3 包含分支的流程圖

**成功/失敗分支：**

```
使用者發送請求
  │
  ├─> 伺服器處理
  │   ├─> 驗證參數
  │   └─> 執行業務邏輯
  │
  ├─> 成功情況：
  │   ├─> 返回 200 狀態碼
  │   └─> 推送成功事件
  │
  └─> 失敗情況：
      ├─> 返回錯誤狀態碼
      └─> 推送錯誤事件
```

### 3.4 多層級流程圖

**複雜的巢狀流程：**

```
使用者開啟聊天室頁面
  │
  ├─> WebSocket 連線建立
  │   ├─> socket.connect()
  │   └─> on('connect') - 連線成功
  │
  ├─> 加入聊天室
  │   ├─> emit('joinRoom')
  │   │   {
  │   │     chatRoom: { id: "room-uuid" }
  │   │   }
  │   │
  │   ├─> on('rpcResponse') - 加入成功
  │   └─> on('userJoined') - 收到廣播通知
  │
  ├─> 獲取歷史資料
  │   ├─> GET /chat-room/{roomId}
  │   └─> GET /chat-message?chatRoomId={roomId}
  │
  └─> 開始監聽事件
      ├─> on('newMessage') - 新訊息
      ├─> on('userJoined') - 使用者加入
      └─> on('userLeft') - 使用者離開
```

### 3.5 流程圖繪製規範

**必須遵守的規範：**

1. **縮排一致**：使用 2 或 4 個空格的統一縮排
2. **對齊整齊**：同層級的項目應該對齊
3. **符號正確**：使用標準的 ASCII 符號
4. **描述清晰**：每個步驟都要有明確的說明
5. **包含資料**：適當時包含資料結構或參數

**良好的縮排範例：**

```
✅ 正確：
步驟 1
  │
  ├─> 子步驟 1.1
  ├─> 子步驟 1.2
  └─> 子步驟 1.3

❌ 錯誤（縮排不一致）：
步驟 1
 │
├─> 子步驟 1.1
  ├─> 子步驟 1.2
└─> 子步驟 1.3
```

### 3.6 流程圖的複雜度控制

**單一流程圖的建議：**
- 最多 3-4 層深度
- 單一流程不超過 15-20 個步驟
- 如果流程過於複雜，考慮拆分成多個小流程圖

**拆分範例：**

```markdown
### 主流程

​```
完整的業務流程
  ├─> 步驟 1: 認證（詳見 3.1 認證流程）
  ├─> 步驟 2: 資料處理（詳見 3.2 資料處理流程）
  └─> 步驟 3: 回應（詳見 3.3 回應流程）
​```

### 3.1 認證流程

​```
[詳細的認證流程圖]
​```

### 3.2 資料處理流程

​```
[詳細的資料處理流程圖]
​```
```

---

## 4. 時序圖繪製指南

### 4.1 基本時序圖結構

時序圖用於展示不同系統角色之間的互動順序：

```
[客戶端]                    [伺服器]
   │                           │
   ├─── 請求 ──────────────────>│
   │                           │ (處理中)
   │<──── 回應 ─────────────────┤
   │                           │
```

### 4.2 標準符號說明

| 符號       | 用途           | 說明                     |
| ---------- | -------------- | ------------------------ |
| `[角色]`   | 系統角色標題   | 放在時序圖頂部           |
| `│`        | 生命線         | 表示角色的存在時間       |
| `├───>`    | 請求箭頭       | 從發送者指向接收者       |
| `<────┤`   | 回應箭頭       | 從接收者指向發送者       |
| `(狀態)`   | 處理狀態       | 標示當前處理的狀態       |

### 4.3 多角色時序圖

**三方互動範例：**

```
[客戶端]          [API Gateway]          [資料庫]
   │                    │                    │
   ├─── 登入請求 ──────>│                    │
   │                    ├─── 驗證 Token ────>│
   │                    │<──── 使用者資料 ───┤
   │                    │                    │
   │<──── 登入成功 ─────┤                    │
   │                    │                    │
```

### 4.4 包含狀態的時序圖

**顯示處理狀態：**

```
[使用者]                [WebSocket Server]         [AI Engine]
   │                           │                        │
   ├─── 發送訊息 ─────────────>│                        │
   │                           │ (建立訊息)              │
   │<─── newMessage ───────────┤                        │
   │                           │                        │
   │<─── aiThinking ───────────┤                        │
   │                           │                        │
   │                           ├─── 請求 AI 回覆 ──────>│
   │                           │                        │ (生成中)
   │                           │<──── AI 回覆 ──────────┤
   │                           │ (儲存訊息)              │
   │<─── aiComplete ───────────┤                        │
   │<─── newMessage ───────────┤                        │
   │                           │                        │
```

### 4.5 WebSocket 連線生命週期時序圖

**完整的連線週期：**

```
[客戶端]                    [伺服器]
   │                           │
   ├─── socket.connect() ─────>│ (連線建立)
   │                           │
   │<──── 'connect' ───────────┤
   │                           │
   ├─── emit('joinRoom') ─────>│
   │                           │ (加入房間)
   │<─── 'rpcResponse' ────────┤
   │<─── 'userJoined' ─────────┤ (廣播)
   │                           │
   │    (正常使用期間)           │
   │                           │
   ├─── emit('leaveRoom') ────>│
   │                           │ (離開房間)
   │<─── 'rpcResponse' ────────┤
   │                           │
   ├─── socket.disconnect() ──>│ (斷線)
   │                           │
```

### 4.6 錯誤處理時序圖

**包含錯誤分支：**

```
[客戶端]                    [伺服器]
   │                           │
   ├─── 認證請求 ──────────────>│
   │                           │ (驗證 Token)
   │                           │
   │    成功情況：               │
   │<──── 200 OK ───────────────┤
   │                           │
   │    失敗情況：               │
   │<──── 401 Unauthorized ─────┤
   │                           │
   │    (引導使用者重新登入)      │
   │                           │
```

### 4.7 時序圖繪製規範

**必須遵守的規範：**

1. **角色對齊**：所有角色標題應該對齊
2. **生命線垂直**：每個角色的生命線（`│`）保持垂直
3. **箭頭方向**：請求向右（`───>`），回應向左（`<───`）
4. **時間順序**：從上到下表示時間流逝
5. **狀態標示**：重要的處理狀態用括號標示

**對齊範例：**

```
✅ 正確對齊：
[客戶端]                    [伺服器]                    [資料庫]
   │                           │                           │

❌ 錯誤對齊：
[客戶端]     [伺服器]    [資料庫]
   │           │          │
```

---

## 5. 事件流程描述

### 5.1 事件流程的標準格式

事件流程應該清楚列出每個步驟，並標示觸發的事件：

```markdown
**事件流程：**

​```
使用者操作
  ├─> POST /api/endpoint (REST API)
  ├─> on('eventName') - 事件說明
  ├─> [Server] 伺服器處理
  │   ├─> 子步驟 1
  │   └─> 子步驟 2
  ├─> broadcast: eventName (廣播事件)
  └─> 完成
​```
```

### 5.2 API 呼叫標示

**REST API 呼叫格式：**
```
POST /chat-message
GET /chat-room/{roomId}
PUT /user/{userId}
DELETE /message/{messageId}
```

**WebSocket 事件格式：**
```
emit('joinRoom')           // 客戶端發送
on('rpcResponse')          // 客戶端接收
broadcast: newMessage      // 伺服器廣播
```

### 5.3 包含資料結構的事件流程

```markdown
**事件流程：**

​```
使用者發送訊息
  │
  ├─> POST /chat-message
  │   {
  │     chatRoomId: "room-uuid",
  │     content: "訊息內容",
  │     type: "TEXT"
  │   }
  │
  └─> [Server] 建立訊息
        │
        ├─> broadcast: newMessage (使用者訊息)
        │   {
        │     id: "msg-uuid",
        │     content: "訊息內容",
        │     sender: { ... }
        │   }
        │
        └─> broadcast: aiThinking (AI 開始思考)
​```
```

### 5.4 AI 處理流程範例

**完整的 AI 互動流程：**

```markdown
**AI 事件流程圖：**

​```
使用者發送訊息
    │
    ├─> POST /chat-message (REST API)
    │
    └─> [Server] 建立訊息
          │
          ├─> broadcast: newMessage (使用者訊息)
          │
          ├─> broadcast: aiThinking (AI 開始思考)
          │
          ├─> [AI Engine] 生成回覆
          │   ├─> 查詢 RAG 向量資料庫
          │   ├─> 組織上下文記憶
          │   └─> 呼叫 AI 模型 (xxx 秒)
          │
          ├─> 成功情況:
          │   ├─> broadcast: aiComplete (AI 思考完成)
          │   └─> broadcast: newMessage (AI 回覆訊息)
          │
          └─> 失敗情況:
              └─> broadcast: aiError (AI 處理錯誤)
                  {
                    statusCode: 500,
                    error: "AIProcessError",
                    message: "錯誤原因說明"
                  }
​```
```

### 5.5 並行處理流程

**多個並行操作：**

```
使用者登入
  │
  ├─> [並行處理]
  │   ├─> 驗證帳號密碼
  │   ├─> 檢查使用者狀態
  │   └─> 記錄登入日誌
  │
  ├─> [結果匯總]
  │
  └─> 返回登入結果
```

### 5.6 條件分支流程

**根據條件執行不同流程：**

```
檢查聊天室類型
  │
  ├─> 如果是 AI_ASSISTANT 類型:
  │   ├─> 觸發 AI 處理流程
  │   ├─> 等待 AI 回覆
  │   └─> 推送 AI 訊息
  │
  ├─> 如果是 GROUP 類型:
  │   ├─> 廣播給所有成員
  │   └─> 不觸發 AI
  │
  └─> 如果是 PRIVATE 類型:
      └─> 只推送給指定成員
```

---

## 6. 連線生命週期文件

### 6.1 連線生命週期的重要性

連線生命週期文件應該描述從連線建立到結束的完整過程，包含：
- 初始連線
- 認證
- 正常使用
- 斷線處理
- 重新連線

### 6.2 標準連線生命週期結構

```markdown
### 連線生命週期

​```
[客戶端]                    [伺服器]
   │                           │
   ├─── socket.connect() ─────>│ (連線建立)
   │                           │ (驗證 Token)
   │                           │
   │<──── 認證成功 ────────────┤
   │                           │
   ├─── emit('joinRoom') ─────>│
   │                           │ (加入房間)
   │<─── 'rpcResponse' ────────┤
   │                           │
   │    (正常使用期間)           │
   │                           │
   ├─── emit('leaveRoom') ────>│
   │                           │ (離開房間)
   │<─── 'rpcResponse' ────────┤
   │                           │
   ├─── socket.disconnect() ──>│ (斷線)
   │                           │
​```
```

### 6.3 認證流程詳細說明

```markdown
### 認證流程

**流程說明：** 客戶端在建立 WebSocket 連線時，需要提供 JWT token 進行認證。

**認證流程圖：**

​```
客戶端建立連線
  │
  ├─> 方式 1: 使用 auth 參數（推薦）
  │   socket.io(url, { auth: { token: 'jwt-token' } })
  │
  ├─> 方式 2: 使用 query 參數
  │   socket.io(url, { query: { token: 'jwt-token' } })
  │
  └─> 方式 3: 使用 Authorization Header
      socket.io(url, { extraHeaders: { Authorization: 'Bearer jwt-token' } })

伺服器驗證
  │
  ├─> 成功情況：
  │   ├─> 解析 JWT token
  │   ├─> 提取使用者 ID
  │   └─> 建立連線
  │
  └─> 失敗情況：
      ├─> 未提供 Token (401 Unauthorized)
      └─> Token 無效或過期 (403 Forbidden)
​```
```

### 6.4 斷線重連流程

```markdown
### 斷線重連流程

**流程說明：** 處理網路斷線、伺服器重啟或意外中斷等情況。

**事件流程：**

​```
正常連線狀態
  │
  ├─> 網路中斷 / 伺服器重啟 / 連線逾時
  │
  └─> on('disconnect') 事件觸發

斷線處理
  ├─> 顯示「連線已中斷」訊息
  ├─> 停止發送新訊息
  ├─> 保存當前狀態
  └─> 嘗試重新連線

重新連線流程
  ├─> socket.connect() (Socket.IO 自動重連)
  ├─> on('connect') - 連線成功
  ├─> emit('joinRoom') - 重新加入之前的聊天室
  ├─> on('rpcResponse') - 加入成功
  ├─> on('userJoined') - 收到加入通知
  ├─> GET /chat-message - 獲取斷線期間的訊息
  │   - 使用 lastMessageId 作為參數
  │   - 只獲取斷線後的新訊息
  ├─> 合併並顯示新訊息
  └─> 顯示「已重新連線」訊息
​```
```

---

## 7. 完整情境範例

### 7.1 情境範例模板

每個完整的情境範例應包含以下所有元素：

```markdown
### [編號] 情境[編號]：[情境名稱]

**流程說明：** [一句話概述]

**前置條件：**（可選）
- 條件 1
- 條件 2

**事件流程：**

​```
[詳細的流程圖或事件序列]
​```

**時序圖：**（複雜流程必需）

​```
[客戶端與伺服器的互動時序]
​```

**使用場景：**

1. [場景 1]
2. [場景 2]
3. [場景 3]

**實作重點：**

- [重點 1]
- [重點 2]

**注意事項：**（可選）

- [注意事項 1]
- [注意事項 2]
```

### 7.2 實際範例：建立 AI 助理聊天室

```markdown
### 7.1 情境一：建立 AI 助理聊天室

**流程說明：** 建立一個 AI 助理，然後建立聊天室並將使用者和 AI 助理加入聊天室。

**前置條件：**
- 使用者已登入系統
- 擁有建立聊天室的權限

**事件流程：**

​```
1. POST /ai-customer-service-assistant
   └─> AI 助理建立成功 (回傳 aiAssistant.id)
       {
         "id": 1,
         "name": "客服小幫手",
         "description": "專業的客服助理",
         "status": "ENABLE"
       }

2. POST /chat-room (type: AI_ASSISTANT)
   └─> 聊天室建立成功 (回傳 chatRoom.id, chatParticipants)
       {
         "id": "room-uuid-xxx",
         "type": "AI_ASSISTANT",
         "title": "AI 客服助理",
         "participants": [
           {
             "id": "participant-uuid-1",
             "type": "USER",
             "user": { "id": 123 }
           },
           {
             "id": "participant-uuid-2",
             "type": "AI_CUSTOMER_SERVICE_ASSISTANT",
             "aiCustomerServiceAssistant": { "id": 1 }
           }
         ]
       }
​```

**使用場景：**

1. **初次設定**：管理員為客戶設定專屬的 AI 助理
2. **功能測試**：開發人員測試 AI 助理功能
3. **客戶支援**：為新客戶快速建立 AI 諮詢管道

**實作重點：**

- 先建立 AI 助理，獲取 AI 助理 ID
- 使用 AI 助理 ID 建立聊天室時指定 `aiCustomerServiceAssistantId`
- 聊天室類型必須設定為 `AI_ASSISTANT`
- 確認回傳的參與者列表包含使用者和 AI 助理

**注意事項：**

- AI 助理的狀態必須為 `ENABLE` 才能正常運作
- 一個聊天室只能有一個 AI 助理參與者
```

### 7.3 實際範例：進入聊天室

```markdown
### 7.2 情境二：進入聊天室

**流程說明：** 使用者開啟應用程式後，連線到 WebSocket 並進入已存在的聊天室，載入歷史訊息。

**事件流程：**

​```
使用者開啟聊天室頁面
  │
  ├─> WebSocket 連線建立
  │   ├─> socket.connect()
  │   │   {
  │   │     auth: { token: 'jwt-token' }
  │   │   }
  │   │
  │   └─> on('connect') - 連線成功
  │
  ├─> 加入聊天室
  │   ├─> emit('joinRoom')
  │   │   {
  │   │     chatRoom: { id: "room-uuid" }
  │   │   }
  │   │
  │   ├─> on('rpcResponse') - 加入成功
  │   │   {
  │   │     statusCode: 200,
  │   │     data: { chatRoom: { id: "room-uuid" } },
  │   │     message: "成功加入聊天室"
  │   │   }
  │   │
  │   └─> on('userJoined') - 收到自己加入的廣播通知
  │
  ├─> 獲取聊天室資訊
  │   ├─> GET /chat-room/{roomId}
  │   │   回傳聊天室詳細資訊、參與者列表
  │   │
  │   └─> 顯示聊天室標題和參與者
  │
  ├─> 獲取歷史訊息
  │   ├─> GET /chat-message?chatRoomId={roomId}&page=1&limit=20
  │   │   回傳最近 20 筆訊息（倒序）
  │   │
  │   └─> 顯示歷史聊天記錄
  │
  └─> 開始監聽聊天室事件
      ├─> on('newMessage') - 新訊息
      ├─> on('userJoined') - 其他使用者加入
      ├─> on('userLeft') - 其他使用者離開
      ├─> on('aiThinking') - AI 思考中 (AI 聊天室)
      ├─> on('aiComplete') - AI 完成回覆 (AI 聊天室)
      └─> on('aiError') - AI 處理錯誤 (AI 聊天室)
​```

**時序圖：**

​```
[客戶端]          [WebSocket Server]      [REST API]      [資料庫]
   │                     │                    │               │
   ├─ connect() ────────>│                    │               │
   │                     │ (驗證 Token)        │               │
   │<─ 'connect' ────────┤                    │               │
   │                     │                    │               │
   ├─ emit('joinRoom') ─>│                    │               │
   │                     │                    │               │
   │<─ 'rpcResponse' ────┤                    │               │
   │<─ 'userJoined' ─────┤ (廣播)             │               │
   │                     │                    │               │
   ├─ GET /chat-room/{id} ──────────────────>│               │
   │                     │                    ├─ 查詢 ───────>│
   │                     │                    │<─ 資料 ───────┤
   │<─ 聊天室資訊 ───────────────────────────┤               │
   │                     │                    │               │
   ├─ GET /chat-message ────────────────────>│               │
   │                     │                    ├─ 查詢 ───────>│
   │                     │                    │<─ 訊息列表 ───┤
   │<─ 歷史訊息 ─────────────────────────────┤               │
   │                     │                    │               │
   │ (開始監聽即時事件)   │                    │               │
   │                     │                    │               │
​```

**使用場景：**

1. 使用者從聊天室列表點擊進入特定聊天室
2. 使用者刷新頁面後重新進入聊天室
3. 從其他頁面（如個人設定）返回聊天室
4. 使用者在多個裝置上同時開啟同一個聊天室

**實作重點：**

- **先連線後加入**：確保 WebSocket 連線建立成功後再發送 joinRoom
- **歷史訊息優先**：先載入歷史訊息，讓使用者看到之前的對話記錄
- **避免重複顯示**：區分歷史訊息和即時訊息，使用訊息 ID 去重
- **錯誤處理**：處理連線失敗、認證失敗、找不到聊天室等錯誤情況
- **載入狀態**：顯示適當的載入動畫，提升使用者體驗

**注意事項：**

- 如果連線失敗，應該顯示錯誤訊息並提供重試選項
- 歷史訊息應該支援分頁載入（向上滾動載入更多）
- 收到自己的 `userJoined` 事件時，不需要顯示通知
- 監聽事件應該在元件卸載時移除，避免記憶體洩漏
```

### 7.4 實際範例：AI 助理對話

```markdown
### 7.3 情境三：AI 助理對話

**流程說明：** 使用者與 AI 助理進行對話，包含訊息發送、AI 思考、AI 回覆的完整流程。

**前置條件：**
- 使用者已加入 AI_ASSISTANT 類型的聊天室
- WebSocket 連線正常
- AI 助理狀態為 ENABLE

**事件流程：**

​```
使用者發送問題
  ├─> POST /chat-message
  │   {
  │     chatRoomId: "room-uuid",
  │     content: "如何使用這個系統？",
  │     type: "TEXT"
  │   }
  │
  ├─> on('newMessage') - 顯示使用者訊息
  │   {
  │     id: "msg-user-uuid",
  │     content: "如何使用這個系統？",
  │     sender: {
  │       type: "USER",
  │       user: { id: 123, name: "使用者" }
  │     }
  │   }
  │
  ├─> on('aiThinking') - 顯示 AI 思考中
  │   {
  │     statusCode: 200,
  │     message: "AI 助理正在思考中...",
  │     data: {
  │       chatRoom: { id: "room-uuid" }
  │     }
  │   }
  │
  ├─> [AI Engine 處理]
  │   ├─> 查詢 RAG 向量資料庫
  │   │   - 搜尋相關的知識文件
  │   │   - 計算相似度分數
  │   │   - 選取最相關的 3-5 筆資料
  │   │
  │   ├─> 組織上下文記憶
  │   │   - 獲取最近 10 筆對話記錄
  │   │   - 建構對話上下文
  │   │
  │   └─> 呼叫 AI 模型生成回覆 (2-5 秒)
  │       - 使用檢索到的知識
  │       - 結合對話上下文
  │       - 生成自然語言回覆
  │
  ├─> on('aiComplete') - AI 思考完成
  │   {
  │     statusCode: 200,
  │     message: "AI 助理已完成回覆"
  │   }
  │
  └─> on('newMessage') - 顯示 AI 回覆
      {
        id: "msg-ai-uuid",
        content: "歡迎使用！這個系統提供...",
        sender: {
          type: "AI_CUSTOMER_SERVICE_ASSISTANT",
          aiCustomerServiceAssistant: {
            id: 1,
            name: "客服小幫手"
          }
        }
      }
​```

**時序圖：**

​```
[使用者]    [客戶端]    [WebSocket]    [REST API]    [AI Engine]    [RAG DB]
   │           │             │              │              │             │
   ├─ 輸入 ───>│             │              │              │             │
   │           ├─ POST ──────────────────────>│              │             │
   │           │             │              │ (建立訊息)    │             │
   │           │<─ newMessage ──────────────┤              │             │
   │<─ 顯示 ───┤             │              │              │             │
   │           │             │              │              │             │
   │           │<─ aiThinking ──────────────┤              │             │
   │<─ 思考中 ─┤             │              │              │             │
   │           │             │              ├─ AI 請求 ───>│             │
   │           │             │              │              ├─ 查詢 ─────>│
   │           │             │              │              │<─ 知識 ─────┤
   │           │             │              │              │ (生成中)    │
   │           │             │              │<─ AI 回覆 ───┤             │
   │           │             │              │ (儲存訊息)    │             │
   │           │<─ aiComplete ──────────────┤              │             │
   │           │<─ newMessage ──────────────┤              │             │
   │<─ 顯示 ───┤             │              │              │             │
   │           │             │              │              │             │
​```

**使用場景：**

1. **產品諮詢**：使用者詢問產品功能和使用方法
2. **問題排除**：使用者遇到問題，尋求 AI 協助
3. **資訊查詢**：查詢系統相關資訊或文件
4. **操作指引**：詢問如何執行特定操作

**實作重點：**

- **UI 狀態管理**：
  - 收到 `aiThinking` 時，顯示載入動畫（如跳動的點點）
  - 收到 `aiComplete` 時，移除載入動畫
  - 收到 `newMessage` 時，顯示 AI 的回覆訊息

- **錯誤處理**：
  - 監聽 `aiError` 事件，處理 AI 處理失敗的情況
  - 顯示友善的錯誤訊息，而非技術性錯誤
  - 允許使用者重新發送訊息

- **使用者體驗**：
  - 訊息發送後立即顯示，不等待伺服器確認
  - AI 思考時間較長，需要適當的視覺反饋
  - 區分使用者訊息和 AI 訊息的顯示樣式

**注意事項：**

- AI 回覆時間可能因查詢複雜度而異（通常 2-10 秒）
- 如果 AI 處理超時，會觸發 `aiError` 事件
- 多個使用者在同一聊天室時，AI 只會回覆觸發訊息的使用者
- 建議限制訊息發送頻率，避免過度消耗 AI 資源
```

### 7.5 實際範例：使用者離開聊天室

```markdown
### 7.4 情境四：使用者離開聊天室

**流程說明：** 使用者主動離開聊天室，其他成員會收到離開通知。

**事件流程：**

​```
使用者 A 主動離開聊天室
  ├─> emit('leaveRoom')
  │   {
  │     chatRoom: { id: "room-uuid" }
  │   }
  │
  ├─> on('rpcResponse') - 離開成功回應 (使用者 A 收到)
  │   {
  │     statusCode: 200,
  │     data: { chatRoom: { id: "room-uuid" } },
  │     message: "成功離開聊天室"
  │   }
  │
  └─> on('userLeft') - 使用者離開通知 (使用者 B 收到)
      {
        statusCode: 200,
        data: {
          chatParticipant: {
            type: "USER",
            user: { id: 123 }
          },
          chatRoom: { id: "room-uuid" }
        },
        message: "使用者離開聊天室"
      }

使用者 A 的處理
  ├─> 停止監聽該房間的所有事件
  ├─> 清理本地聊天記錄（可選）
  ├─> 更新 UI 狀態（例如返回聊天室列表頁）
  └─> 釋放相關資源

使用者 B 的處理
  ├─> 收到 'userLeft' 事件
  ├─> 顯示「使用者 A 已離開聊天室」通知（可選）
  ├─> 更新在線成員列表
  └─> 移除使用者 A 的狀態指示器
​```

**使用場景：**

1. 使用者主動點擊「離開聊天室」按鈕
2. 切換到其他聊天室前先離開當前房間
3. 應用程式登出前清理所有房間連線
4. 使用者關閉聊天室視窗或分頁

**實作重點：**

- **事件清理**：離開房間後，應移除所有該房間的事件監聽器
- **UI 更新**：立即更新 UI，不等待伺服器確認
- **資料清理**：可選擇性清理本地的聊天記錄（或保留供下次進入時使用）
- **錯誤處理**：處理離開失敗的情況（如網路錯誤）

**注意事項：**

- 如果使用者直接關閉瀏覽器分頁，WebSocket 會自動斷線，伺服器會自動處理
- 建議在元件卸載時主動調用 `leaveRoom`，確保清理完整
- 多個聊天室時，確保只離開指定的房間，不影響其他房間
```

---

## 8. 檢查清單

### 8.1 使用情境檢查清單

撰寫使用情境時，請確認：

**基本要素：**
- [ ] 情境編號和名稱清晰明確
- [ ] 包含流程說明（一句話概述）
- [ ] 提供詳細的事件流程圖
- [ ] 列出 2-5 個具體的使用場景
- [ ] 標註實作重點（如適用）

**流程完整性：**
- [ ] 包含起始條件或觸發點
- [ ] 詳細列出每個步驟
- [ ] 包含成功和失敗的分支
- [ ] 說明最終結果或狀態
- [ ] 標示重要的資料結構

**可讀性：**
- [ ] 使用清晰的縮排和對齊
- [ ] 符號使用正確且一致
- [ ] 每個步驟都有明確說明
- [ ] 技術術語使用正確
- [ ] 包含適當的註解或說明

### 8.2 流程圖檢查清單

繪製流程圖時，請確認：

**結構規範：**
- [ ] 使用標準的 ASCII 符號（`│`, `├─>`, `└─>`）
- [ ] 縮排一致（2 或 4 個空格）
- [ ] 同層級項目對齊整齊
- [ ] 最多 3-4 層深度
- [ ] 單一流程不超過 20 個步驟

**內容完整：**
- [ ] 每個步驟都有清晰的說明
- [ ] 包含成功和失敗的分支
- [ ] 標示重要的處理狀態
- [ ] 包含必要的資料結構
- [ ] 註明 API 呼叫或事件名稱

**視覺效果：**
- [ ] 流程方向清晰（由上而下）
- [ ] 分支邏輯易於理解
- [ ] 重要步驟有適當強調
- [ ] 整體版面整潔易讀

### 8.3 時序圖檢查清單

繪製時序圖時，請確認：

**格式規範：**
- [ ] 角色標題對齊且清晰
- [ ] 生命線垂直且完整
- [ ] 箭頭方向正確（請求→，回應←）
- [ ] 時間順序由上而下
- [ ] 處理狀態用括號標示

**內容完整：**
- [ ] 包含所有相關的系統角色
- [ ] 每個互動都有清楚的說明
- [ ] 標示請求和回應的資料
- [ ] 包含錯誤處理流程
- [ ] 註明重要的時間延遲

**可讀性：**
- [ ] 角色間距適當（建議 20-25 個字元）
- [ ] 箭頭長度一致
- [ ] 說明文字清晰簡潔
- [ ] 整體版面平衡

### 8.4 完整情境範例檢查清單

撰寫完整情境範例時，請確認：

**結構完整性：**
- [ ] 包含流程說明
- [ ] 包含前置條件（如適用）
- [ ] 包含詳細的事件流程
- [ ] 包含時序圖（複雜流程必需）
- [ ] 包含使用場景列表
- [ ] 包含實作重點
- [ ] 包含注意事項（如適用）

**技術準確性：**
- [ ] API 端點路徑正確
- [ ] 事件名稱正確
- [ ] 資料結構符合實際規格
- [ ] 錯誤代碼和訊息正確
- [ ] 時序邏輯合理

**實用性：**
- [ ] 場景貼近實際使用情況
- [ ] 實作重點具有指導價值
- [ ] 注意事項能預防常見錯誤
- [ ] 範例代碼可直接參考使用

**文件品質：**
- [ ] 語言清晰易懂
- [ ] 格式一致規範
- [ ] 沒有錯別字或語法錯誤
- [ ] 連結和參照正確

---

## 附錄 A：流程圖符號快速參考

### ASCII 字元符號表

```
垂直線：│
左分支（中）：├─>
左分支（末）：└─>
右分支回應：<─┤
橫線：─
箭頭：>
```

### 複製貼上模板

**基本流程：**
```
步驟名稱
  │
  ├─> 子步驟 1
  ├─> 子步驟 2
  └─> 子步驟 3
```

**時序圖：**
```
[角色 A]                    [角色 B]
   │                           │
   ├─── 請求 ──────────────────>│
   │                           │ (處理中)
   │<──── 回應 ─────────────────┤
   │                           │
```

**分支結構：**
```
條件判斷
  │
  ├─> 情況 A：
  │   ├─> 處理 A1
  │   └─> 處理 A2
  │
  └─> 情況 B：
      ├─> 處理 B1
      └─> 處理 B2
```

---

## 附錄 B：實用技巧

### B.1 如何組織複雜流程

**問題：** 流程太複雜，單一流程圖難以表達

**解決方案：**
1. **分層描述**：主流程 → 子流程詳細說明
2. **時序分離**：使用時序圖補充流程圖
3. **情境拆分**：將大情境拆分成多個小情境
4. **使用參照**：「詳見章節 X.X」

### B.2 如何處理並行流程

**問題：** 多個操作同時進行，難以線性表達

**解決方案：**
```
主流程
  │
  ├─> [並行處理]
  │   ├─> 並行操作 1
  │   ├─> 並行操作 2
  │   └─> 並行操作 3
  │
  ├─> [等待所有完成]
  │
  └─> 後續處理
```

### B.3 如何標示非同步操作

**問題：** 非同步操作的時序難以表達

**解決方案：**
```
使用者操作
  │
  ├─> 發送請求 (非同步)
  │
  ├─> 繼續其他操作
  │
  └─> (稍後) 收到回應
      └─> 處理結果
```

### B.4 如何呈現循環流程

**問題：** 需要表達重複執行的流程

**解決方案：**
```
開始輪詢
  │
  ├─> [每 5 秒執行一次]
  │   ├─> 檢查狀態
  │   ├─> 處理結果
  │   └─> 如果未完成，繼續輪詢
  │
  └─> 完成後停止
```

---

**文件版本歷史：**

| 版本 | 日期       | 說明                                                   |
| ---- | ---------- | ------------------------------------------------------ |
| v1.0 | 2025-11-12 | 初版發布，基於 chat.md 建立系統分析文件撰寫標準 |

---

**© 2025 Sys AI Dataset API Documentation Team. All rights reserved.**
